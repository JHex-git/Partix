#version 450
// Declare the struct once
struct Particle {
    bool alive;
    bool prevAlive;
    float lifetime;
    vec3 position;
    vec3 velocity;
    float size;
    vec3 color;
    uvec4 seed;
};

layout(std140, binding = 0) uniform View
{
    mat4 view_mat;
    mat4 projection_mat;
    float prevTime;
    float currentTime;
    float deltaTime;
} view;

layout(std140, binding = 1) uniform Emitter
{
    vec3 position;
    vec3 direction;
    int emitCountPerFrame;
    float lifetime;
    float emitVelocity;
    float jitterAngleRange;
    float spriteSize;
    int maxParticleCount;
} emitter;

layout(std140, binding = 1) buffer InputParticles {
    Particle particles[];
} inputParticles;

layout(std140, binding = 2) buffer OutputParticles {
    Particle particles[];
} outputParticles;

layout(binding = 0) uniform atomic_uint emitCount;


layout(local_size_x = 256) in;

/*
    This random number generator is copied from UE5
*/

// 4D random number generator inspired by PCGs (permuted congruential generator)
// Using a **simple** Feistel cipher in place of the usual xor shift permutation step
// http://jcgt.org/published/0009/03/02/
// @param v = 4D integer coordinate
// @return four elements w/ 32 random bits each (0-0xffffffff).
uvec4 Rand4DPCG32(uvec4 p)
{
	// taking a signed int then reinterpreting as unsigned gives good behavior for negatives
	uvec4 v = uvec4(p);

	// Linear congruential step.
	v = v * 1664525u + 1013904223u;

	// shuffle
	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;

	// xoring high bits into low makes all 32 bits pretty good
	v ^= (v >> 16u);

	// final shuffle
	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;

	return v;
}
/*
    This random number generator is copied from UE5
*/
uvec4 RandomUInt4(inout Particle particle)
{
	++particle.seed.x;
	particle.seed.w = particle.seed.x ^ particle.seed.y;
	return Rand4DPCG32(particle.seed);
}
uint   RandomUInt(inout Particle particle) { return RandomUInt4(particle).x; }
uvec2  RandomUInt2(inout Particle particle) { return RandomUInt4(particle).xy; }
uvec3  RandomUInt3(inout Particle particle) { return RandomUInt4(particle).xyz; }

vec4 RandomFloat4(inout Particle particle)
{
	uvec4 v = RandomUInt4(particle);
	return vec4((v >> 8) & 0x00ffffff) / 16777216.0; // 0x01000000 == 16777216
}
float  RandomFloat(inout Particle particle)  { return RandomFloat4(particle).x; }
vec2 RandomFloat2(inout Particle particle) { return RandomFloat4(particle).xy; }
vec3 RandomFloat3(inout Particle particle) { return RandomFloat4(particle).xyz; }

vec3 rotatePerpendicularAxis(vec3 v, vec3 axis, float angle) {
    // 确保旋转轴是单位向量且与v垂直
    vec3 n = normalize(axis);
    float c = cos(angle);
    float s = sin(angle);
    
    // 计算平面内的旋转分量
    return v * c + cross(n, v) * s;
}

void EmitterSpawn_Init(inout Particle particle)
{
    particle.prevAlive = particle.alive;
    if (!particle.alive)
    {
        // Check if we can emit a new particle
        uint count = atomicCounterIncrement(emitCount);
        if (count < emitter.emitCountPerFrame)
        {
            particle.alive = true;
            particle.lifetime = emitter.lifetime + (RandomFloat(particle) - 0.5) * emitter.lifetime * 0.25; // Random lifetime
            particle.position = vec3(emitter.position); // Random position
            particle.size = emitter.spriteSize;
        }
    }
    else
    {
        particle.lifetime -= view.deltaTime;
        if (particle.lifetime <= 0.0)
        {
            particle.alive = false;
        }
    }
}

#define PI 3.14159265358979323846
void Fountain_Init(inout Particle particle)
{
    float theta = RandomFloat(particle) * 2.0 * PI; // Random angle
    vec3 velocity_horizontal = vec3(cos(theta), 0.0, sin(theta)); // Random direction in XZ plane
    vec3 velocity = normalize(emitter.direction + velocity_horizontal);
    float jitter_angle = (RandomFloat(particle) * 0.5 - 1) * emitter.jitterAngleRange / 180.0 * PI;
    vec3 axis = normalize(cross(emitter.direction, velocity_horizontal)); // Rotation axis
    velocity = rotatePerpendicularAxis(velocity, axis, jitter_angle); // Rotate the velocity vector
    particle.velocity = velocity * emitter.emitVelocity;
}

void RigidBody_Update(inout Particle particle)
{
    // Update the particle's position based on its velocity and lifetime
    particle.position += particle.velocity * view.deltaTime;
}

void AddForce_Update(inout Particle particle)
{
    // Example force: gravity
    vec3 gravity_acceleration = vec3(0.0, -9.81, 0.0); // Gravity force
    particle.velocity += gravity_acceleration * view.deltaTime;
}

void Collision_Update(inout Particle particle)
{
    if (particle.position.y < 0.0)
    {
        particle.alive = false;
    }
}

void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (id < emitter.maxParticleCount)
    {
        Particle particle = inputParticles.particles[id];

        EmitterSpawn_Init(particle);
        if (particle.alive && !particle.prevAlive)
        {
            Fountain_Init(particle);
        }

        if (particle.alive)
        {
            RigidBody_Update(particle);
            AddForce_Update(particle);
            Collision_Update(particle);
        }

        outputParticles.particles[id] = particle;
    }
}